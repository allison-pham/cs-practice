import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.utils.viewport.*;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Circle;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Intersector;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;

public class Pong extends ApplicationAdapter
{
    private OrthographicCamera camera; //the camera to our world
    private Viewport viewport; //maintains the ratios of your world
    private ShapeRenderer renderer; //used to draw textures and fonts
    private BitmapFont font; //used to draw fonts (text)
    private SpriteBatch batch; //also needed to draw fonts (text)

    private Rectangle leftPaddle;
    private Rectangle rightPaddle;

    private Circle ball;
    private float ballAngle;
    private boolean started = false;
    private int player1Score = 0;
    private int player2Score = 0;

    public static final float WORLD_WIDTH = 800;
    public static final float WORLD_HEIGHT = 480;
    public static final float PADDLE_WIDTH = 20;
    public static final float PADDLE_HEIGHT = 80;
    public static final float RADIUS = 15;
    public static final float PADDLE_SPEED = 10;
    public static final float BALL_SPEED = 10;

    @Override
    public void create(){
   	 camera = new OrthographicCamera();
   	 viewport = new FitViewport(WORLD_WIDTH, WORLD_HEIGHT, camera);
   	 renderer = new ShapeRenderer();
   	 font = new BitmapFont();
   	 batch = new SpriteBatch();

   	 leftPaddle = new Rectangle(0, 0, PADDLE_WIDTH, PADDLE_HEIGHT);
   	 rightPaddle = new Rectangle(WORLD_WIDTH - PADDLE_WIDTH, WORLD_HEIGHT / 2 - PADDLE_HEIGHT / 2,
   		 PADDLE_WIDTH, PADDLE_HEIGHT);
   	 ball = new Circle(WORLD_WIDTH / 2 - RADIUS, WORLD_HEIGHT / 2 - RADIUS, RADIUS);
   	 ballAngle = 0;
    }

    @Override//running 60 times a second
    public void render(){
   	 viewport.apply();

   	 Gdx.gl.glClearColor(0, 0, 0.2f, 1);
   	 Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

   	 if(started)
   	 {
   		 ball.x += BALL_SPEED * MathUtils.cosDeg(ballAngle);
   		 ball.y += BALL_SPEED * MathUtils.sinDeg(ballAngle);
   	 }

   	 if(Gdx.input.isKeyPressed(Keys.UP))
   	 {
   		 rightPaddle.y += PADDLE_SPEED; 		 
   	 }
   	 if(Gdx.input.isKeyPressed(Keys.DOWN))
   	 {
   		 rightPaddle.y -= PADDLE_SPEED; 		 
   	 }
   	 if(Gdx.input.isKeyPressed(Keys.W))
   	 {
   		 leftPaddle.y += PADDLE_SPEED; 		 
   	 }
   	 if(Gdx.input.isKeyPressed(Keys.S))
   	 {
   		 leftPaddle.y -= PADDLE_SPEED;
   	 }
   	 if(Gdx.input.isKeyPressed(Keys.SPACE))
   	 {
   		 started = true;  
   	 }

   	 //TODO
   	 //dont allow the paddles to go off the screen leftPaddle.y is the y coordinate
   	 // of the bottom left of the paddle, there are also constants for the PADDLE_HEIGHT
   	 //and WORLD_HEIGHT
   	 //if they go past the bottom, set the y value back to 0 (leftPaddle.y = 0), and something similar
   	 //if it goes past the top
   	 //you need to check the top and bottom of the screen for the leftPaddle and the rightPaddle

   	 //TODO
   	 //check if the ball goes past the top or bottom of the screen (use ball.y to
   	 //get the y value of the center of the ball) if it does go off the screen
   	 // set the variable 'ballAngle" to ballAngle * -1

   	 //checks for collision of the ball and paddle
   	 if(Intersector.overlaps(ball, rightPaddle))
   	 {
   		 float percentOfPaddle = (ball.y - rightPaddle.y) / PADDLE_HEIGHT;
   		 ballAngle = 225 - (percentOfPaddle * 90);

   	 }
   	 if(Intersector.overlaps(ball, leftPaddle))
   	 {
   		 float percentOfPaddle = (ball.y - leftPaddle.y) / PADDLE_HEIGHT;
   		 ballAngle = -45 + (percentOfPaddle * 90);

   	 }

   	 //TODO
   	 //Check if the ball goes past the left side of the screen (use ball.x)
   	 //if it does set the ball.x and ball.y back to the center of the screen
   	 //set the variable ballAngle to 0
   	 //set the variable 'started' to false
   	 //increase the variable 'player2Score' by one

   	 //TODO
   	 //Check if the ball goes past the right side of the screen (use ball.x)
   	 //if it does set the ball.x and ball.y back to the center of the screen
   	 //set the variable ballAngle to 0
   	 //set the variable 'started' to false
   	 //increase the variable 'player1Score' by one

   	 renderer.setProjectionMatrix(viewport.getCamera().combined);
   	 renderer.setColor(Color.WHITE);
   	 renderer.begin(ShapeType.Filled);

   	 float r = (float)Math.random();
   	 float g = (float)Math.random();
   	 float b = (float)Math.random();
   	 Color temp = new Color(r, g, b, 1);
   	 renderer.setColor(temp);
   	 renderer.rect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
   	 renderer.rect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);
   	 renderer.circle(ball.x, ball.y, ball.radius);

   	 renderer.end();

   	 GlyphLayout layout = new GlyphLayout(font, "Press SPACE_BAR to start");
   	 batch.begin();
   	 if(!started)
   	 {
   		 font.draw(batch, layout,
       		 WORLD_WIDTH / 2 - layout.width / 2,
       		 WORLD_HEIGHT/2 + layout.height / 2 + 20);
   	 }
   	 font.draw(batch, player1Score + ":" + player2Score, WORLD_WIDTH / 2 - 20, 440);
   	 batch.end();
    }

    @Override
    public void resize(int width, int height){
   	 viewport.update(width, height, true);
    }

    @Override
    public void dispose(){
   	 renderer.dispose();
   	 batch.dispose();
    }

}